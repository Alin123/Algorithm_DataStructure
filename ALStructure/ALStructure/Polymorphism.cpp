//
//  Polymorphism.cpp
//  ALStructure
//
//  Created by lianzhandong on 2017/12/14.
//  Copyright © 2017年 ALin. All rights reserved.
//

#include "Polymorphism.hpp"


void Intellectual::study() {
    printf("知识分子为中华民族之崛起而读书！\n");
}

void Intellectual::working() {
    printf("知识分子运用自己的所学创造价值！\n");
}

Intellectual::~Intellectual() {
    printf("显示声明的虚的析构函数必须手动定义！");
}

void Teacher::study() {
    printf("老师通过教案来学习知识！\n");
}

void Teacher::working() {
    printf("老师正在教书育人！\n");
}

Teacher::~Teacher() {
    printf("必须为多态基类生命虚析构函数！\n");
}

void Stu::study() {
    printf("学生通过上课、读书学习知识！\n");
}

void Stu::working() {
    printf("学生的工作就是上课听讲！\n");
}

Stu::~Stu() {
    printf("防止指向子类的指针或子类的引用在对象应该被消耗时只调用了父类的析构函数，造成子类占用的资源无法释放！\n");
}


const double PI=3.14159;

Shape::Shape(double x, double y) {
    this->x = x;
    this->y = y;
}

Shape::~Shape() {
    printf("销毁虚基类Shape！！！");
}

Square::~Square() {
    printf("销毁子类Square！！！");
}

double Square::getArea() {
    double area = x * y;
    printf("矩形的面积为%.2f", area);
    return area;
}

Circle::~Circle() {
    printf("销毁子类Circle！！！");
}

double Circle::getArea() {
    double area = PI * x * x;
    printf("圆形的面积是%.2f", area);
    return area;
}

/**********
1、虚函数
 
虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。
 
2、纯虚函数
 
纯虚函数是在基类中声明虚函数的方法后加“=0”，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。我们把那些类中的确存在，但是在父类中无法确定具体实现的成员函数称为纯虚函数。
2.2 引入原因
2.2.1 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数；
2.2.2 在很多情况下，基类本身生成对象是不合情理的（形状作为一个基类可以派生出矩形、原型等子类，但形状本身生成对象明显不合常理）。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重载以实现多态性。纯虚函数在基类中应该只有声明，没有具体的定义，即使给出了纯虚函数的定义也会被编译器忽略。

3、抽象类

3.1 包含至少一个纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象，在实际中为了强调一个类是抽象类，可将该类的构造函数说明为保护的访问控制权限。
3.2 在C++中，我们可以把只能用于被继承而不能直接创建对象的类设置为抽象类（Abstract Class）。
3.3 抽象类刻画了一组子类的操作接口的通用语义，这些语义也传给子类。一般而言，抽象类只描述这组子类共同的操作接口，而完整的实现留给子类。
3.4 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类没有重新定义纯虚函数，而派生类只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。
3.5 抽象类的规定
3.5.1 抽象类只能用作其他类的基类，不能建立抽象类对象。
3.5.2 抽象类不能用作参数类型、函数返回类型或显式转换的类型。但抽象类引用（Shape&）、抽象类指针（Shape *）可以，因为它们能代表子类的一个对象。
3.5.3 可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。


4、多态性
指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。
4.1 C++支持两种多态性：编译时多态性，运行时多态性
4.1.1 编译时多态性：通过函数重载和运算符重载来实现的。
4.1.2 运行时多态性：通过继承和虚函数来实现的。

5、虚函数和纯虚函数的区别。
5.1 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
5.2 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现，这就像Java的接口一样。通常把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为很难预料到父类里面的这个函数不在子类里面不去修改它的实现。
5.3 带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在C#中用abstract定义抽象类，而在C++中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。



6、抽象类和接口的区别：
1.类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫做抽象类.而接口只是一个行为的规范或规定，微软的自定义接口总是后带able字段，证明其是表述一类类“我能做。。。”.抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中.
2.接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法;
3.一个类一次可以实现若干个接口,但是只能扩展一个父类
4.接口可以用于支持回调,而继承并不具备这个特点.
5.抽象类不能被密封。
6.抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的.
7.（接口）与非抽象类类似，抽象类也必须为在该类的基类列表中列出的接口的所有成员提供它自己的实现。但是，允许抽象类将接口方法映射到抽象方法上。
8.抽象类实现了oop中的一个原则，把可变的与不可变的分离。抽象类和接口就是定义为不可变的，而把可变的座位子类去实现。
9.好的接口定义应该是具有专一功能性的，而不是多功能的，否则造成接口污染。如果一个类只是实现了这个接口的中一个功能，而不得不去实现接口中的其他方法，就叫接口污染。
10.尽量避免使用继承来实现组建功能，而是使用黑箱复用，即对象组合。因为继承的层次增多，造成最直接的后果就是当你调用这个类群中某一类，就必须把他们全部加载到栈中！后果可想而知.（结合堆栈原理理解）。同时，有心的朋友可以留意到微软在构建一个类时，很多时候用到了对象组合的方法。比如asp.net中，Page类，有Server Request等属性，但其实他们都是某个类的对象。使用Page类的这个对象来调用另外的类的方法和属性，这个是非常基本的一个设计原则。
11.如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法.
 **********/
